## 알고리즘이란 무엇인가?

- 알고리즘
    - 정의 : 주어진 문제를 해결하기 위한 잘 정의된 동작들의 유한집합


- 자료구조
    - 알고리즘의 객체
    - 구조화되고 조직화된 자료의 저장/추출/관리 방법
    - 추상 데이터타입(Abstracted Data Type)
    - 배열, 스택, 큐, 트리, ...


- 알고리즘의 선택
    - 하나의 문제에 대해 여러 알고리즘이 존재
    - 절대적인 최상의 알고리즘은 없다.
    - __주어진 문제와 환경을 먼저 숙지하라.__
        + 알고리즘의 장단점을 파악하고 있는 것이 중요하다.
    - 속도와 자원(resource)의 상관관계
        + 일반적으로 속도가 빠를 수록 자원을 많이 차지하게됨.
        + ex) 임베디드 시스템의 경우 메모리 용량이 작음. 메모리를 적게 차지하는 알고리즘을 사용
        + 반면에 성능이 좋은 PC의 경우 보통은 자원이 고려대상이 되지않음.
    - 단순한 알고리즘이 좋다.
        - 지나친 속도결벽증은 금울
        - 알고리즘의 사용빈도에 따른 선택


- 알고리즘의 예 : 두 정수의 곱셈
    - 전통적인 곱셈의 기본연산
        + 임의의 정수 * 한자리 정수
        + 두 정수의 더하기
    - 기본연산이라 하기에는 너무 복잡하다.
        + 사람에게는 적합, 컴퓨터에게는 어렵다.
    - `a la russe` 라는 알고리즘은 어떨까?


- 알고리즘의 예 : a la russe
    - 해당 알고리즘의 과정
        + 1) 두 정수를 첫번째, 두번째에 쓴다.
        + 2) 첫번째 수가 홀수이면, 두번째수를 세번째칸에 기록한다.
        + 3) 첫번째 수를 2로 나누고(나머지 버림), 두번째 수에 2를 곱한다.
        + 4) 첫번째 수가 0보다 크면 2)로 돌아간다.
        + 5) 세번째 칸의 수를 모두 더한다.
    - 기본연산
        + 정수를 2로 나눈다.
        + 정수에 2를 곱한다.
        + 두 정수를 더한다.

<br>

## 알고리즘 분석

- 경험적 분석과 수학적 분석
    - 분석은 알고리즘을 정확히 선택하기위한 방법
    - 시간소요량 vs 공간소요량
    - 경험적 분석(Empirical Analysis)
        + 실제 코드를 작성 후, 실행하여 시간을 측정
        + 데이터수를 다르게 하여 함수관계 유추
    - 수학적 분석(Mathematical Analysis)
        + 알고리즘 자체를 가지고 수학적인 분석을 함.


- 최악의 경우와 최선의 경우
    - 최악의 경우 (Worst Case)
        + 가장 많은 시간과 자원을 필요로 하는 경우
    - 최선의 경우 (Best Case)
        + 가장 적은 시간과 자원만이 소요되는 경우
    - 평균적 경우(Average Case)
        + 개념은 모호함..
        + 자료의 균일분포? 가장 많은 빈도의 경우?


- 알고리즘 분석 예

```
void algorithm(int a[], int n){
    int i, j;
    for (i = 0; i < n; i++) {
        // c1
        for (j = 0; j < i; j++){
            // c2
        }
    }
}
```

- T(N) = c1 + (c1 + c2) + (c1 + c2*2) + ... + (c1 + c2*(N-1)) = c1 * N + c2 * (1+2+ ... + (N-1)) = 0.5*c2*N*N + (c1 - 0.5*c2)*N
- c1, c2는 각 루프문 내에서 실행시간이다.


- 알고리즘의 유형
    - 1(상수)
        + 입력자료수와 관계없이 일정한 실행시간
        + 해쉬 검색 알고리즘 등
    - log N
        + Divide & Conquer 방법 사용시
        + 이진검색, 이진트리검색 등
    - N
        + Scan방법 사용 시
        + 선형검색 등
    - N log N
        + Divide & Conquer & Merge 방법 사용시
        + 병합정렬 등
    - N^2
        + 이중루프
        + 삽입정렬, 선택정렬 등
    - N^3
        + 삼중루프


- 알고리즘 성능 표기법 (Big-Oh)
    - 알고리즘의 성능을 객관적으로 표현하는 방법
    - O 표기법(Big-Oh notation)
        + 실행시간 함수 T(N)이 N_0보다 큰 N에 대해 항상 C_0f(N)보다 작거나 같은 C_0와 N_0가 존재한다면 T(N)은 O(f(N))이라고 한다.
        + 즉, N > N_0인 모든 N에 대해 T(N) <= C_0f(N)이 만족하면 T(N) = O(f(N))이다.
    - 보통 T(N)에서 가장 영향력있는 항이 선택된다.
    - ex) T(N) = 3N^2 + 1 이라면 O(N^2)
        + N >= 1인 모든 N에 대해 T(N) <= 4N^2


- 알고리즘 성능표기법 ($\Omega$, $\Theta$)